
"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

import arktypes

class bullet_dynamics_t(object):

    __slots__ = ["bodyUniqueId", "linkIndex", "mass", "lateralFriction", "spinningFriction", "rollingFriction", "restitution", "linearDamping", "angularDamping", "contactStiffness", "contactDamping", "frictionAnchor", "localInertiaDiagonal", "ccdSweptSphereRadius", "contactProcessingThreshold", "activationState", "jointDamping", "anisotropicFriction", "maxJointVelocity", "collisionMargin", "jointLowerLimit", "jointUpperLimit", "jointLimitForce", "physicsClientId"]

    __typenames__ = ["arktypes.int32", "arktypes.int32", "float", "float", "float", "float", "float", "float", "float", "float", "float", "arktypes.int32", "arktypes.float_vector_t", "float", "float", "arktypes.int32", "float", "float", "float", "float", "float", "float", "float", "arktypes.int32"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]

    def __init__(self):
        self.bodyUniqueId = arktypes.int32()
        """ LCM Type: arktypes.int32 """
        self.linkIndex = arktypes.int32()
        """
        Required: object unique id, as returned by loadURDF etc.
        LCM Type: arktypes.int32
        """

        self.mass = 0.0
        """
        Required: link index or -1 for the base
        Optional fields
        LCM Type: float
        """

        self.lateralFriction = 0.0
        """
        Mass of the link (or base for linkIndex -1)
        LCM Type: float
        """

        self.spinningFriction = 0.0
        """
        Lateral (linear) contact friction
        LCM Type: float
        """

        self.rollingFriction = 0.0
        """
        Torsional friction around the contact normal
        LCM Type: float
        """

        self.restitution = 0.0
        """
        Torsional friction orthogonal to contact normal
        LCM Type: float
        """

        self.linearDamping = 0.0
        """
        Bounciness of contact (keep < 1, preferably closer to 0)
        LCM Type: float
        """

        self.angularDamping = 0.0
        """
        Linear damping of the link
        LCM Type: float
        """

        self.contactStiffness = 0.0
        """
        Angular damping of the link
        LCM Type: float
        """

        self.contactDamping = 0.0
        """
        Stiffness of the contact constraints
        LCM Type: float
        """

        self.frictionAnchor = arktypes.int32()
        """
        Damping of the contact constraints
        LCM Type: arktypes.int32
        """

        self.localInertiaDiagonal = arktypes.float_vector_t()
        """
        Enable/disable friction anchor
        LCM Type: arktypes.float_vector_t
        """

        self.ccdSweptSphereRadius = 0.0
        """
        Diagonal elements of the inertia tensor
        LCM Type: float
        """

        self.contactProcessingThreshold = 0.0
        """
        Radius of the sphere for continuous collision detection
        LCM Type: float
        """

        self.activationState = arktypes.int32()
        """
        Threshold for processing contacts
        LCM Type: arktypes.int32
        """

        self.jointDamping = 0.0
        """
        Activation state (e.g., sleeping, wake-up state)
        LCM Type: float
        """

        self.anisotropicFriction = 0.0
        """
        Joint damping coefficient
        LCM Type: float
        """

        self.maxJointVelocity = 0.0
        """
        Anisotropic friction coefficient
        LCM Type: float
        """

        self.collisionMargin = 0.0
        """
        Maximum joint velocity
        LCM Type: float
        """

        self.jointLowerLimit = 0.0
        """
        Collision margin
        LCM Type: float
        """

        self.jointUpperLimit = 0.0
        """
        Lower limit of a joint
        LCM Type: float
        """

        self.jointLimitForce = 0.0
        """
        Upper limit of a joint
        LCM Type: float
        """

        self.physicsClientId = arktypes.int32()
        """
        Maximum force applied to satisfy a joint limit
        LCM Type: arktypes.int32
        """


    def encode(self):
        buf = BytesIO()
        buf.write(bullet_dynamics_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        assert self.bodyUniqueId._get_packed_fingerprint() == arktypes.int32._get_packed_fingerprint()
        self.bodyUniqueId._encode_one(buf)
        assert self.linkIndex._get_packed_fingerprint() == arktypes.int32._get_packed_fingerprint()
        self.linkIndex._encode_one(buf)
        buf.write(struct.pack(">fffffffff", self.mass, self.lateralFriction, self.spinningFriction, self.rollingFriction, self.restitution, self.linearDamping, self.angularDamping, self.contactStiffness, self.contactDamping))
        assert self.frictionAnchor._get_packed_fingerprint() == arktypes.int32._get_packed_fingerprint()
        self.frictionAnchor._encode_one(buf)
        assert self.localInertiaDiagonal._get_packed_fingerprint() == arktypes.float_vector_t._get_packed_fingerprint()
        self.localInertiaDiagonal._encode_one(buf)
        buf.write(struct.pack(">ff", self.ccdSweptSphereRadius, self.contactProcessingThreshold))
        assert self.activationState._get_packed_fingerprint() == arktypes.int32._get_packed_fingerprint()
        self.activationState._encode_one(buf)
        buf.write(struct.pack(">fffffff", self.jointDamping, self.anisotropicFriction, self.maxJointVelocity, self.collisionMargin, self.jointLowerLimit, self.jointUpperLimit, self.jointLimitForce))
        assert self.physicsClientId._get_packed_fingerprint() == arktypes.int32._get_packed_fingerprint()
        self.physicsClientId._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != bullet_dynamics_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return bullet_dynamics_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = bullet_dynamics_t()
        self.bodyUniqueId = arktypes.int32._decode_one(buf)
        self.linkIndex = arktypes.int32._decode_one(buf)
        self.mass, self.lateralFriction, self.spinningFriction, self.rollingFriction, self.restitution, self.linearDamping, self.angularDamping, self.contactStiffness, self.contactDamping = struct.unpack(">fffffffff", buf.read(36))
        self.frictionAnchor = arktypes.int32._decode_one(buf)
        self.localInertiaDiagonal = arktypes.float_vector_t._decode_one(buf)
        self.ccdSweptSphereRadius, self.contactProcessingThreshold = struct.unpack(">ff", buf.read(8))
        self.activationState = arktypes.int32._decode_one(buf)
        self.jointDamping, self.anisotropicFriction, self.maxJointVelocity, self.collisionMargin, self.jointLowerLimit, self.jointUpperLimit, self.jointLimitForce = struct.unpack(">fffffff", buf.read(28))
        self.physicsClientId = arktypes.int32._decode_one(buf)
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if bullet_dynamics_t in parents: return 0
        newparents = parents + [bullet_dynamics_t]
        tmphash = (0x36750e1745eafd78+ arktypes.int32._get_hash_recursive(newparents)+ arktypes.int32._get_hash_recursive(newparents)+ arktypes.int32._get_hash_recursive(newparents)+ arktypes.float_vector_t._get_hash_recursive(newparents)+ arktypes.int32._get_hash_recursive(newparents)+ arktypes.int32._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if bullet_dynamics_t._packed_fingerprint is None:
            bullet_dynamics_t._packed_fingerprint = struct.pack(">Q", bullet_dynamics_t._get_hash_recursive([]))
        return bullet_dynamics_t._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", bullet_dynamics_t._get_packed_fingerprint())[0]

