package _arktypes_sensor;

// Messages for commonly used sensors.

// Joint state information for a multi‑DoF robot.
struct joint_state_t {
    // Number of degrees of freedom.
    int16_t ndof;

    // Name of each joint, indexed 0‥ndof‑1.
    string name[ndof];

    // Position of each joint, one‑to‑one with `name`.
    float position[ndof];

    // Velocity of each joint, one‑to‑one with `name`.
    float velocity[ndof];

    // Actuator effort or commanded torque for each joint.
    float effort[ndof];

    // External torque estimated or sensed at each joint.
    float ext_torque[ndof];
}

// Joystick state message.
struct joy_t {

    // Number of analog axes reported by the device.
    int8_t naxes;

    // Current value of each axis (typically normalized in [-1, 1]).
    float axes[naxes];

    // Number of buttons on the device.
    int8_t nbuttons;

    // Current state of each button (0 = released, non-zero = pressed).
    int32_t buttons[nbuttons];
}

// A representation of an image.
struct image_t {

  // The frame name where this image is obtained
  string frame_name;

  // The image width in pixels.
  int32_t width;

  // The image height in pixels.
  int32_t height;

  // The physical memory size per a single row in bytes.
  int32_t row_stride;

  // The size of `data` in bytes.
  int32_t size;

  // The data that contains actual image.
  byte data[size];

  // The boolean to denote if the data is stored in the bigendian order.
  boolean bigendian;

  // The semantic meaning of pixels.
  int8_t pixel_format;

  // The data type for a channel.
  int8_t channel_type;

  // The compression method.
  int8_t compression_method;

  // enum for pixel_format.
  const int8_t PIXEL_FORMAT_GRAY       = 0;
  const int8_t PIXEL_FORMAT_RGB        = 1;
  const int8_t PIXEL_FORMAT_BGR        = 2;
  const int8_t PIXEL_FORMAT_RGBA       = 3;
  const int8_t PIXEL_FORMAT_BGRA       = 4;
  const int8_t PIXEL_FORMAT_DEPTH      = 5;
  const int8_t PIXEL_FORMAT_LABEL      = 6;
  const int8_t PIXEL_FORMAT_MASK       = 7;
  const int8_t PIXEL_FORMAT_DISPARITY  = 8;
  const int8_t PIXEL_FORMAT_BAYER_BGGR = 9;
  const int8_t PIXEL_FORMAT_BAYER_RGGB = 10;
  const int8_t PIXEL_FORMAT_BAYER_GBRG = 11;
  const int8_t PIXEL_FORMAT_BAYER_GRBG = 12;
  const int8_t PIXEL_FORMAT_INVALID    = -1;

  // enum for channel_type.
  const int8_t CHANNEL_TYPE_INT8    = 0;
  const int8_t CHANNEL_TYPE_UINT8   = 1;
  const int8_t CHANNEL_TYPE_INT16   = 2;
  const int8_t CHANNEL_TYPE_UINT16  = 3;
  const int8_t CHANNEL_TYPE_INT32   = 4;
  const int8_t CHANNEL_TYPE_UINT32  = 5;
  const int8_t CHANNEL_TYPE_FLOAT32 = 6;
  const int8_t CHANNEL_TYPE_FLOAT64 = 7;
  const int8_t CHANNEL_TYPE_INVALID = -1;

  // enum for compression_method.
  const int8_t COMPRESSION_METHOD_NOT_COMPRESSED = 0;
  const int8_t COMPRESSION_METHOD_ZLIB           = 1;
  const int8_t COMPRESSION_METHOD_JPEG           = 2;
  const int8_t COMPRESSION_METHOD_PNG            = 3;
  const int8_t COMPRESSION_METHOD_INVALID        = -1;
}

// Synchronized RGBD (Image + Depth)
struct rgbd_t {
  // RGB image.
  image_t image;

  // Depth map.
  image_t depth;
}

// Laser Scan
struct laser_scan_t {
    // Number of valid samples in this scan.
    int64_t n;

    // Bearing angle of each laser beam, indexed 0..n‑1.
    float angles[n];

    // Distance measured along each beam, matched 1‑to‑1 with `angles`.
    float ranges[n];
}

// IMU
struct imu_t {
    // Orientation of the IMU sensor expressed as a quaternion.
    _arktypes_geometry.quaternion_t orientation;

    // Angular velocity of the sensor frame.
    _arktypes_geometry.vector3_t angular_velocity;

    // Linear acceleration of the sensor frame.
    _arktypes_geometry.vector3_t linear_acceleration;
}
